<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++程序设计基础(4) - 复合类型数据：数组</title>
      <link href="/2020/08/16/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80(4)%20-%20%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE_%E6%95%B0%E7%BB%84/"/>
      <url>/2020/08/16/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80(4)%20-%20%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE_%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>介绍数组和C风格字符串的处理, 已经一些十分常用的数组算法.</p><a id="more"></a><h2 id="一维数组">一维数组</h2><ul><li><p><strong>数组的定义</strong>: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]; <span class="keyword">double</span> b[<span class="number">20</span>]; <span class="keyword">char</span> c[<span class="number">80</span>];</span><br></pre></td></tr></table></figure> 数组的大小必须是正的整数类型的常量表达式.</p></li><li><p><strong>一维数组赋初值</strong>: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> a1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[<span class="number">5</span>] = &#123;<span class="number">1</span>&#125;; <span class="comment">//后面默认初值为0</span></span><br></pre></td></tr></table></figure> 注意: 如果数组未赋初值, 则数组中元素的值是不确定的(有的编译器会清为特定的值, 有的编译器保留残留值)</p></li><li><p><strong>计算数组元素个数</strong>: <code>sizeof(a)/sizeof(a[0])</code></p></li></ul><h2 id="多维数组">多维数组</h2><ul><li><strong>多维数组的定义</strong>: <code>int a[2][3][4];</code></li><li><strong>多维数组在内存中的存储</strong>: 按<code>a[0][0][0], a[0][0][1], a[0][0][2], a[0][0][3], a[0][1][0], a[0][1][1], a[0][1][2], a[0][1][3], a[0][2][0], ...</code> 依次存放, 占据连续空间</li><li><strong>多维数组赋初值</strong>:</li></ul><p>​ (1) 按行形式: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">8</span>&#125;,&#123;<span class="number">0</span>&#125;&#125;; <span class="comment">//每行初值不足补0</span></span><br><span class="line"><span class="keyword">int</span> b[][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">8</span>&#125;,&#123;<span class="number">0</span>&#125;&#125;; <span class="comment">//第一维大小可以省略,由初值行数确定. 但第二维大小不可省略.</span></span><br></pre></td></tr></table></figure> ​ (2) 按整体形式: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>&#125;; <span class="comment">//数据按照内存中存放的顺序依次存储</span></span><br><span class="line"><span class="keyword">int</span> b[][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>&#125;; <span class="comment">//第一维大小由初值个数所能构成的行数确定, 此处为2.</span></span><br></pre></td></tr></table></figure></p><h2 id="c风格字符串字符数组">C风格字符串(字符数组)</h2><ul><li><strong>C风格字符串</strong>: 用字符数组存放并用 '\0' 结束字符串, 用字符串首地址来使用字符串.</li><li><strong>赋初值</strong>: 可以按照普通字符数组赋初值的方式(不提倡, 繁琐且容易遗漏串结束标志<code>\0</code>), 通常按照赋字符串初值的方式. 见下例:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">10</span>] = &#123;<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>&#125;;  <span class="comment">//遗漏了串结束标志</span></span><br><span class="line"><span class="keyword">char</span> s2[] = &#123;<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>,<span class="string">'\0'</span>&#125;;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">char</span> s3[] = <span class="string">"Hello"</span>;  <span class="comment">//与s2的赋值等价</span></span><br></pre></td></tr></table></figure><ul><li><strong>字符串的输入输出</strong>: C风格字符串可以直接输入输出, 无需使用循环</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">80</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;  <span class="comment">//直接输入</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//直接输出</span></span><br></pre></td></tr></table></figure><p>几种输入方式的比较:</p><p>(定义<code>char ch; char s[80];</code>)</p><p><code>cin &gt;&gt; ch;</code> //输入一个字符到ch中, 跳过空格、跳格、回车等空白间隔符</p><p><code>ch = cin.get();</code> //等价于<code>cin.get(ch)</code>, 读取一个字符保存到ch中, 不跳过空白间隔符</p><p><code>cin &gt;&gt; s;</code> //输入一个单词到ch中, 遇到空白间隔符截断</p><p><code>cin.get(s, 80, '\n');</code> //第一个参数表示输入字符串到字符数组s中, 第二个参数表示此次输入保存的最大字符数(79个有效字符加一个串结束标志), 第三个参数(默认参数为<code>\n</code>,常常省略)表示遇到该字符结束输入, 不读取该字符, 并添加串结束标志. 注意: 如果前80个字符都没有回车字符, 那么将读取79个字符, 添加串结束标志, 并产生输入错误标志.</p><p><code>if(!cin) cin.clear();</code> //清除输入错误标志</p><p><code>cin.getline(s, 80, '\n');</code> //类似于<code>cin.get(s, 80, '\n')</code>, 只不过会读取回车字符<code>\n</code>然后丢弃.</p><ul><li><p><strong>字符串的处理</strong>:</p><ol type="1"><li><p>利用串结束标志控制循环</p></li><li><p>使用库函数</p></li></ol></li></ul><p><code>strlen(s);</code> //求字符串s的长度, 不含串结束标志. 英文: length</p><p><code>strcpy(s1, s2);</code> //将字符串s2复制到s1中. 英文: copy</p><p><code>strcmp(s1, s2);</code> //按字典序比较s1和s2. 相同时函数值为0, 不相同时比较ASCII码, s1&gt;s2时函数值为1, s1&lt;s2时函数值为-1. (注意, 大写字符的ASCII码小于小写字母的). 英文: compare</p><p><code>strcat(s1, s2);</code> //将字符串s2合并到s1的后面. 英文: catenate</p><p><code>strlwr(s);</code> //变为小写. 英文: lowercase</p><p><code>strupr(s);</code> //变为大写. 英文: uppercase</p><h2 id="常用数组算法">常用数组算法</h2><p>非常常用! 非常重要! 必须掌握!</p><p>为突出重点, 我们这里只列出核心代码</p><h3 id="有序插入">有序插入</h3><p>有序插入指在一个已经排序的数组中将数据插入, 使得到的数组保持已排序的状态. 此处我们以升序数组中有序插入为例.</p><p>假设已有定义<code>double d[20]; double x; int i,n=19;</code> 其中<code>double d[20]</code>中已有<code>n=19</code>个升序排列的数值. 我们要将<code>x</code>有序插入数组<code>d</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span> &amp;&amp; x&lt;d[i]; i--) &#123;  <span class="comment">//从后往前扫描数组直到插入位置, i始终处于空位的前一位</span></span><br><span class="line">    d[i+<span class="number">1</span>] = d[i];  <span class="comment">//扫描过的数据向后移动一位</span></span><br><span class="line">&#125;</span><br><span class="line">d[i+<span class="number">1</span>] = x; n++;  <span class="comment">// 插入数据, 数据个数增加1个</span></span><br></pre></td></tr></table></figure><h3 id="顺序查找">顺序查找</h3><p>较为简单. 假设已有定义<code>double d[20]; double x; int i,n=20;</code> 其中<code>double d[20]</code>中已有<code>n=20</code>个值. 我们在数组d中查找x. 只要</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(d[i] == x) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (i &lt; n) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"查找的数是数组中第"</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">"个数"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"查找的数不在数组中"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br></pre></td></tr></table></figure><p>即可</p><h3 id="折半查找">折半查找</h3><p>折半查找的前提是数组有序. 对于有序数组, 折半查找的效率大大高于顺序查找.</p><p>假设已有定义<code>double d[20]; double x; int i,n=20;</code> 其中<code>double d[20]</code>中已有<code>n=20</code>个值. 我们在数组d中查找x.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> low, up;  <span class="comment">//定义low, up, 分别表示正在查找区间的上界和下界</span></span><br><span class="line"><span class="keyword">for</span> (low = <span class="number">0</span>, up = n<span class="number">-1</span>; low &lt;= up; ) &#123;</span><br><span class="line">    i = (low + up)/<span class="number">2</span>;  <span class="comment">//取中间数的下标i</span></span><br><span class="line">    <span class="keyword">if</span>(d[i] == x) <span class="keyword">break</span>;  <span class="comment">//找到就跳出循环</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; d[i]) &#123; up = i<span class="number">-1</span>; &#125;  <span class="comment">//x在d[low]~d[i-1]内</span></span><br><span class="line">    <span class="keyword">else</span> &#123; low = i+<span class="number">1</span>; &#125;  <span class="comment">//x在d[i+1]~d[up]内</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (low &gt; up) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"查找的数不在数组中"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"查找的是数组中第"</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">"个数"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="选择法排序">选择法排序</h3><p>选择法排序(升序)的核心思想就是每次选择未处理的数中最小的, 放到左端已处理的数据之后.</p><p>假设已有定义<code>double d[100],t; int n,i,k,j;</code> 我们固定字母k用来记录下标.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (k=i, j=i+<span class="number">1</span>; j&lt;n; j++)  </span><br><span class="line">    <span class="keyword">if</span>(d[j]&lt;d[k]) k = j;  <span class="comment">//找i到n-1范围内的最小值, 下标记录在k中</span></span><br><span class="line"><span class="keyword">if</span>(k!=i) &#123; t = d[k]; d[k] = d[i]; d[i] = t; &#125;  <span class="comment">//若最小值不在d[i], 则交换到d[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡法排序">冒泡法排序</h3><p>冒泡排序法(升序), 就是每次从前往后对相邻的数据进行比较, 若次序不正确, 则交换次序. 注意到最大的数据每次交换后都移至最后, 所以每次扫描的数据就要减少1个. 这样, 经过n-1次扫描, 排序就完成了.</p><p>具体实现是这样的: 假设已有定义<code>double d[100],t; int n,i,k;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = n<span class="number">-1</span>; k&gt;<span class="number">0</span>; k--) &#123;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;k; i++)   <span class="comment">//扫描数组的前k+1项数据</span></span><br><span class="line"><span class="keyword">if</span> (d[i]&gt;d[i+<span class="number">1</span>]) &#123; t = d[i]; d[i] = d[i+<span class="number">1</span>]; d[i+<span class="number">1</span>] = t; &#125;</span><br><span class="line">        <span class="comment">//相邻两项比较, 次序不对就换序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序设计基础(3) - 选择结构与循环结构</title>
      <link href="/2020/08/15/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80(3)%20-%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"/>
      <url>/2020/08/15/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80(3)%20-%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>介绍两种基本的结构: 选择结构与循环结构</p><a id="more"></a><h2 id="选择结构">选择结构</h2><h3 id="if语句">if语句</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式) &#123;...&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式) &#123;...&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式) &#123;...&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="条件表达式">条件表达式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表达式<span class="number">1</span> ? 表达式<span class="number">2</span> : 表达式<span class="number">3</span></span><br></pre></td></tr></table></figure><p>表达式1为true时计算表达式2的值作为结果, 为false时计算表达式3的值作为结果.</p><h3 id="switch语句">switch语句</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(整数表达式)   <span class="comment">//包括int及其派生类型、字符类型、逻辑类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> 常量表达式<span class="number">1</span>: 语句序列<span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> 常量表达式<span class="number">2</span>: 语句序列<span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> 常量表达式n: 语句序列n</span><br><span class="line"><span class="keyword">default</span>: 语句序列n+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(grade)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; “<span class="number">90</span>~<span class="number">100</span>” &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; “<span class="number">80</span>~<span class="number">89</span>” &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; “<span class="number">70</span>~<span class="number">79</span>” &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; “<span class="number">60</span>~<span class="number">69</span>” &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; “<span class="number">0</span>~<span class="number">59</span>” &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环结构">循环结构</h2><h3 id="while语句和do...while语句">while语句和do...while语句</h3><p>while语句:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)&#123;...&#125;</span><br></pre></td></tr></table></figure><p>do...while语句:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;...&#125;<span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure><p>两者的区别是while语句先进行判断再决定是否执行语句, 而do...while先执行一次内嵌语句再进行判断.</p><h3 id="for语句">for语句</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure><p>其中 表达式1为初始操作; 表达式2为循环条件; 表达式3在内嵌语句后执行</p><blockquote><p><strong>算法. 求最大公约数(辗转相除法)</strong> 求a, b两个整数的最大公约数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b; b!=<span class="number">0</span>; r=a%b, a=b, b=r);</span><br></pre></td></tr></table></figure> 则得到的a为最大公约数.</p></blockquote><h3 id="break和continue语句">break和continue语句</h3><p>break跳出循环, 但只跳出一层循环. continue终止本次循环, 进入下一次循环.</p><blockquote><p><strong>算法. 判断是否为素数</strong> 设输入的数据为n, 判断其是否为素数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (sqrtn = <span class="built_in">sqrt</span>((<span class="keyword">double</span>)n), i = <span class="number">2</span>; i &lt;= sqrtn; i++);</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (n &gt;= <span class="number">2</span> &amp;&amp; i &gt; sqrtn) <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; “ is prime” &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; “ is <span class="keyword">not</span> prime” &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序设计基础(2) - 数据与运算</title>
      <link href="/2020/08/15/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80(2)%20-%20%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%BF%90%E7%AE%97/"/>
      <url>/2020/08/15/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80(2)%20-%20%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>主要介绍C++的基本数据类型和运算符, 略去了较为简单的内容</p><a id="more"></a><h2 id="c标识符">C++标识符</h2><ul><li><p>C++标识符的含义: C++中使用的名字, 如变量名、类型名、函数名等</p></li><li><p>合法的C++标识符：由字母、数字、下划线构成，首字母不能是数字.</p></li></ul><h2 id="常量">常量</h2><ul><li><p>八进制: 前缀为<code>0</code>十六进制: 前缀为<code>0x</code>或<code>0X</code></p></li><li><p>转义序列(预定义): 换行<code>\n</code> (newline), 跳格<code>\t</code> (tab), 回车<code>\r</code> (return), 警报<code>\a</code> (alarm), 回退一个字符<code>\b</code> (backspace), 反斜杠<code>\\</code>, 单引号<code>\'</code> 转义序列(ASCII): 用最多3位八进制(如<code>\103</code>) 或 <code>x</code>加上最多2位十六进制(如<code>\x6f</code>)表示字符.</p></li><li><p>最大整数 <code>maxInt = 0x7fffffff</code>, 最小整数 <code>minInt = 0x80000000</code></p></li><li><p>八进制输出 <code>cout &lt;&lt; oct &lt;&lt; maxInt;</code> 十六进制输出 <code>cout &lt;&lt; hex &lt;&lt; maxInt;</code> 十进制输出 <code>cout &lt;&lt; dec &lt;&lt; maxInt;</code></p></li></ul><h2 id="基本运算及表达式">基本运算及表达式</h2><ul><li><p>结合方向从右向左:</p><ol type="1"><li>部分一元运算: <code>*</code>(指向),<code>&amp;</code>(取地址), <code>new</code>, <code>delete</code>, <code>!</code>, <code>~</code>, <code>++</code>, <code>--</code>, <code>-</code>(取负), <code>sizeof()</code>, 显式转换</li><li>三元运算: <code>? :</code></li><li>赋值运算: <code>=</code>, <code>+=</code>, <code>-=</code>,<code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code></li></ol></li><li><p>左值: 表示存储单元的表达式, 可被赋值. 在C++中, 前置增量/减量运算, 赋值运算的结果是左值. 右值: 不是左值的表达式, 不可被赋值. 常量和计算值是右值.</p></li><li><p>连续输入数据, 以Ctrl^Z结束的方式: <code>while (cin &gt;&gt; x){...}</code></p></li><li><p>显式类型转换: 若定义<code>int a = 3;</code> 将其转换为double类型的方法如下<code>double(a);</code> 或 <code>(double)a;</code> 或 <code>static_cast&lt;double&gt;(a);</code></p></li><li><p>短路表达式: 逻辑表达式(与、或)一旦有了最终结果就不再计算.</p></li></ul><h2 id="位运算">位运算</h2><p>与运算 <code>&amp;</code> : 都为1, 结果才为1.</p><p>或运算 <code>|</code> :只要有一个为1, 结果就为1.</p><p>非运算(取反运算) <code>~</code> : 0变1, 1变0.</p><p>异或运算 <code>^</code> : 不进位加法</p><p>移位运算: 左移 <code>&lt;&lt;</code> (右边补0), 右移 <code>&gt;&gt;</code> (左边拓展高位数字, 有符号类型进行符号拓展, 无符号类型进行0拓展)</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序设计基础(1) - 计算机基础知识</title>
      <link href="/2020/08/15/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80(1)%20-%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/08/15/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80(1)%20-%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>主要介绍进制的转换和计算机数值表示</p><a id="more"></a><h2 id="进制的转换">进制的转换</h2><ol type="1"><li>其它进制转换为十进制</li></ol><p>利用展开式直接计算。例如：将八进制数<span class="math inline">\((137.45)_{8}\)</span>转换为十进制</p><p><span class="math display">\[(137.45)_{8}=1\times8^{2}+3\times8^{1}+7\times8^{0}+4\times8^{-1}+5\times8^{-2}\]</span></p><ol start="2" type="1"><li>十进制转换为其它进制</li></ol><p>整数用短除法(反复除以进制数), 余数倒排. 小数反复乘以进制数, 余数部分依次排列</p><ol start="3" type="1"><li>二进制与八进制, 二进制与十六进制转换</li></ol><p>它们有直接的对应关系, 每3位二进制对应1位八进制, 每4位二进制对应1位十六进制.</p><h2 id="计算机数值表示">计算机数值表示</h2><p>1个<strong>字节</strong>由8位二进位组成, 是计算机的基本存储单位.</p><h3 id="整数表示">整数表示</h3><ul><li><p>无符号整数(unsigned类型): 直接用二进制表示, 高位补0.</p></li><li><p>有符号整数(signed类型): 使用<strong>补码</strong>表示. 规定: 补码的最高位是符号位, 正数为0, 负数为1; 其余的位数用来表示数值.</p></li></ul><p>正数直接用二进制表示, 负数用与正数二进制数相补的数表示(相加进位).</p><h3 id="实数表示-ieee标准">实数表示 (IEEE标准)</h3><p>实数采用二进制标准化科学计数法表示: 先写成二进制小数再使用科学计数法. 如:</p><p><span class="math display">\[+0.001=\underset{\text{符号位}}{+}\underset{\text{尾数部分(小数点以后)}}{1.0000011\ 00010010\ 01101110\ 10010111\ \cdots}\times\underset{\text{指数部分}}{2^{-10}}\]</span></p><p>数据分为三个部分存储: 符号位、指数部分、尾数部分.</p><ul><li><p>符号位: 正数用0, 负数用1.</p></li><li><p>指数部分: 采用<strong>移码</strong>表示法. 对指数部分加上 <span class="math inline">\((0111\cdots111)_{2}\)</span> , 得到的二进制数称为移码. (加上一个大整数是为了将负数转化为正数)</p></li><li><p>尾数部分: 截断时舍入规则为0舍1入. 注意: 单精度和双精度格式的尾数部分只保存小数点后的小数, 而扩展精度的要保存整数部分的1.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Mint安装及LaTeX-Lyx配置踩坑记</title>
      <link href="/2020/07/26/Linux-Mint%E5%AE%89%E8%A3%85%E5%8F%8ALaTeX-Lyx%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
      <url>/2020/07/26/Linux-Mint%E5%AE%89%E8%A3%85%E5%8F%8ALaTeX-Lyx%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本文记录安装Linux Mint系统过程中以及使用Linux版的LaTeX和Lyx时出现的问题，并给出解决方案。</p><a id="more"></a><h2 id="来由">来由</h2><p>前几天在Deepin系统上试图安装Lyx，但是Lyx在Deepin软件源中的版本滞后，无法打开我之前的Lyx文档。于是我便试图在Deepin中加载Ubuntu的软件源。一开始，一切似乎都无比正常，<code>sudo apt-get update</code>顺利执行，说明软件源加载成功。然后，我用<code>sudo apt-cache policy lyx</code>检查了软件源中Lyx的版本，由原来的<code>2.2.2</code>提升到了<code>2.3.5.2</code>，是最新的stable版本。大喜之下，一行<code>sudo apt-get install lyx</code>开始安装，提示要添加三百多个软件包，更新四百多个，删除两百多个。也没多想，就敲了Y，漫长的更新过程大概持续了十几分钟。然后怀着迫切的心情，我立即查看是否安装成功，打开Lyx正常，版本号正确。但很快，我就发现了事情的严重性，开始菜单无法弹出，深度监视器无法打开，最糟糕的是——无法关机，无法重启！只好强制关机，可谁知，关机后便再也无法进入系统（卡在Deepin的徽标界面）。网友们给出的解释是Deepin的图形界面相关的软件包被卸载或者更新，而更新后的软件包可能与其它模块不兼容，因此无法进入系统。</p><p>所以，总结一下，<strong>第一个坑：不要在Deepin上加载Ubuntu软件源！</strong></p><p>LaTeX对于我是刚需，而Lyx对于喜欢记记杂碎问题的我是一大利器。于是，我决定果断放弃Deepin。</p><h2 id="初识linux-mint">初识Linux Mint</h2><p>在网上进行了一番比较，似乎对于个人家用，Ubuntu和Linux Mint是首选，而Linux Mint基于Ubuntu，在图形界面上占优势。便挑选了Linux Mint。</p><p>一番常规操作之后，我用U盘作为启动盘进入了安装程序，磁盘分区可把我分的头都大了，本来就是双硬盘双系统，分出的区特别多。这里建议<strong>可以事先在Windows上用DiskGenius查看原本有哪些分区，分别对应什么，然后手机拍照记录下来</strong>。这样等到真正分区的时候就不会乱了。</p><p>麻烦的事情发生了：我选择将启动引导器安装到<code>dev/sdb</code>（我的SSD），可是却报错</p><blockquote><p>Ubuntu Error: The partition table format in use on your disks normally requires you to create a separate partition for boot loader code. This partition should be marked for use as a "Reserved BIOS boot area" and should be at least 1MB in size. Note that this is not the same as a partition mounted on <code>/boot</code>.</p></blockquote><p>于是，我按照它的提示，创建了一个保留BIOS分区。选择安装启动引导器到该分区，没有报错。但这只是冰山一角。</p><p>安装即将结束的时候，报错：</p><blockquote><p>fatal error: 执行 ‘grub-install /dev/sdb' 失败，这是一个致命错误</p></blockquote><p>解决方案：<strong>制作Linux Mint启动盘不可以用Ultra ISO</strong>，它会默认选择UEFI的启动模式，而且Linux Mint的原生安装包实际上还缺失两个文件，需要制作时补上。那么如何制作呢？<strong>使用rufus，避开UEFI启动的选项</strong>，制作前，它会提示自动下载那两个文件。使用重新制作的启动盘，那两个错误都不会出现。并且<strong>启动引导器就直接安装在硬盘上，不要安装在分区中，更无需创建保留BIOS分区</strong>。</p><p>Linux Mint刚刚打开的时候，第一眼注意到的就是它优美的图形界面。字体或许有点小，但这是容易调节的。</p><h2 id="安装texlive和lyx">安装Texlive和Lyx</h2><p>LaTeX是刚需，自然少不了安装相关的环境。安装Texlive和Lyx除了耗时较长以外，没有出现错误信息。问题出现在全部安装完毕，打开Lyx编写文档时。我选择“从模版新建”，并选择ctex.lyx ，这时弹出提示信息ctexart.cls和一些sty找不到，导致无法编译文档。经过检查，Texlive已经完整安装，ctexart.cls和相关sty文件都存在。</p><p>解决方案：<strong>终端中执行<code>texhash</code> ，然后在Lyx中“重新配置Lyx“</strong>。</p><h2 id="一些其它的坑">一些其它的坑</h2><p>关于Linux分区大小问题：最好一次到位，后面调整比较麻烦。要充分预估后面安装的软件数量。我这次的分区为： <code>/boot</code> 500MB；<code>/</code> 46GB；<code>/home</code> 45GB</p><p>但是实际使用过程中发现，安装完必备的软件（主要是Texlive较大）已经占用了27GB <code>/</code> 下的空间了，而 <code>/home</code> 才放了不到2GB的文件。实际上，<code>/home</code> 的用处不是很大，因为在Windows和Linux双系统中，可以挂载Windows下的磁盘，也就是说，Linux下可以访问Windows系统的文件（但Windows下不能直接访问Linux的文件，原因是磁盘文件系统不同（Linux为ext4））。所以，在Linux下我们存储文件可以存放在磁盘的任意位置，不需要存放于 <code>/home</code> 中，在分区时根目录 <code>/</code> 应该适当预留大一些，而 <code>/home</code> 则不需要太大。</p><p>如果让我重新分区，我会分为 <strong><code>/boot</code> 500MB；<code>/</code> 71GB；<code>/home</code> 20GB</strong> <strong>这是Linux Mint和Windows双系统中比较合适的比例。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> LaTeX </tag>
            
            <tag> Lyx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合元素个数与线性空间的维数</title>
      <link href="/2020/07/12/%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%B4%E6%95%B0/"/>
      <url>/2020/07/12/%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>证明一个集合元素个数不超过线性空间的维数, 可以去证明这个集合的元素是线性无关的. 而证明线性空间的维数不超过集合元素个数n, 可以考虑证明线性空间中任意n+1个元素都线性相关. 这在域论中是常见的手法.</p><p>下面给出几个例子.</p><a id="more"></a><blockquote><p><strong>问题 1</strong> 设<span class="math inline">\(V\)</span>为 n 维实线性空间, <span class="math inline">\(M\subseteq\mathrm{End}V\)</span>, 满足</p><ol type="1"><li><p><span class="math inline">\(\mathrm{id}\in M,0\notin M\)</span>;</p></li><li><p>若<span class="math inline">\(\mathscr{A},\mathscr{B}\in M\)</span>, 则<span class="math inline">\(\mathscr{AB}\in M\)</span>或<span class="math inline">\(\mathscr{BA}\in M\)</span>;</p></li><li><p>若<span class="math inline">\(\mathscr{A},\mathscr{B}\in M\)</span>, 则<span class="math inline">\(\mathscr{AB}=\mathscr{BA}\)</span>或<span class="math inline">\(\mathscr{AB}=-\mathscr{BA}\)</span>;</p></li><li><p>若<span class="math inline">\(\mathscr{A}\in M\)</span>且<span class="math inline">\(\mathscr{A}\neq\pm\mathrm{id}\)</span>, 则存在<span class="math inline">\(\mathscr{B}\in M\)</span>, s.t. <span class="math inline">\(\mathscr{AB=-BA}\)</span></p></li></ol><p>证明: <span class="math inline">\(M\)</span>中的元素个数不超过<span class="math inline">\(2n^{2}\)</span>.</p></blockquote><p>证明: (提示: 证明一个集合元素个数不超过线性空间的维数, 可以去证明这个集合的元素是线性无关的. 此处<span class="math inline">\(n^{2}\)</span>暗示维数, <span class="math inline">\(\mathscr{A},-\mathscr{A}\)</span>可以同时出现, 所以有个 2 倍.)</p><p>首先证明<span class="math inline">\(\forall\mathscr{A}\in M\)</span>, 都有<span class="math inline">\(\mathscr{A}^{2}=\pm\mathrm{id}\)</span>.</p><p>任取<span class="math inline">\(\mathscr{A}\in M\)</span> , 由(2)得<span class="math inline">\(\mathscr{A}^{2}\in M\)</span>. 如果<span class="math inline">\(\mathscr{A}^{2}\neq\pm\mathrm{id}\)</span> , 则由(4), <span class="math inline">\(\exists\mathscr{B}\in M\)</span>, s.t. <span class="math inline">\(\mathscr{A}^{2}\mathscr{B}=-\mathscr{BA}^{2}\)</span>.</p><p>另一方面, 若<span class="math inline">\(\mathscr{AB}=\mathscr{BA}\)</span>, 则<span class="math inline">\(\mathscr{A}^{2}\mathscr{B}=\mathscr{A}(\mathscr{AB})=\mathscr{A}(\mathscr{BA})=(\mathscr{AB})\mathscr{A}=\mathscr{B}\mathscr{A}^{2}\)</span>; 若<span class="math inline">\(\mathscr{AB}=-\mathscr{BA}\)</span>, 则<span class="math inline">\(\mathscr{A}^{2}\mathscr{B}=\mathscr{A}(\mathscr{AB})=\mathscr{A}(-\mathscr{BA})=-(\mathscr{AB})\mathscr{A}=\mathscr{B}\mathscr{A}^{2}\)</span>. 即总有<span class="math inline">\(\mathscr{A}^{2}\mathscr{B}=\mathscr{B}\mathscr{A}^{2}\)</span>. 所以<span class="math inline">\(M\ni\mathscr{A}^{2}\mathscr{B}=0\)</span>, 这与(1)矛盾.</p><p>然后证明<span class="math inline">\(M\)</span>中不同且不互为相反数的元素线性无关.</p><p>(反证法)假设<span class="math inline">\(M\)</span>中不同且不互为相反数的元素线性相关, 那么一定可以找到一个最小的<span class="math inline">\(n\)</span>, 使得<span class="math inline">\(M\)</span>中不同且不互为相反数的<span class="math inline">\(n\)</span>个元素线性相关.</p><p>设<span class="math inline">\(\mathscr{A}_{1}, \mathscr{A}_{2}, \cdots, \mathscr{A}_{n}\in M\)</span>互不相同且<span class="math inline">\(\forall i\neq j\)</span>, <span class="math inline">\(\mathscr{A}_{i}+\mathscr{A}_{j}\neq0\)</span>, <span class="math inline">\(\mathscr{A}_{1}, \mathscr{A}_{2}, \cdots, \mathscr{A}_{n}\)</span>线性相关.</p><p><span class="math inline">\(\exists k_{i}\neq0\)</span> , 使得 <span class="math inline">\(\sum_{i=1}^{n} k_{i} \mathscr{A}_{i}=0\)</span>. 不妨设<span class="math inline">\(\mathscr{A}_{1}=\pm\mathrm{id}\)</span> (否则考虑<span class="math inline">\(\sum_{i=1}^{n} k_{i} \mathscr{A}_{1} \mathscr{A}_{i}=0\)</span>) , 则<span class="math inline">\(\mathscr{A}_{2},\cdots,\mathscr{A}_{n}\neq\pm\mathrm{id}\)</span>.</p><p><span class="math inline">\(\mathscr{A}_{n}\neq\pm\mathrm{id}\)</span>和(4)可知<span class="math inline">\(\mathscr{C}\in M\)</span>, s.t. <span class="math inline">\(\mathscr{A}_{n}\mathscr{C}=-\mathscr{C}\mathscr{A}_{n}\)</span>.</p><p>不妨假设对<span class="math inline">\(1\leq i\leq t\)</span>, <span class="math inline">\(\mathscr{A}_{i}\mathscr{C}=\mathscr{C}\mathscr{A}_{i}\)</span>; 对<span class="math inline">\(t+1\leq i\leq n-1\)</span>, <span class="math inline">\(\mathscr{A}_{i}\mathscr{C}=-\mathscr{C}\mathscr{A}_{i}\)</span>. 对式子</p><p><span class="math display">\[\sum_{i=1}^{n-1}k_{i}\mathscr{A}_{i}=-k_{n}\mathscr{A}_{n}\]</span></p><p>分别用<span class="math inline">\(\mathscr{C}\)</span>左作用和右作用, 得</p><p><span class="math display">\[\sum_{i=1}^{t}k_{i}\mathscr{C}\mathscr{A}_{i}+\sum_{i=t}^{n-1}k_{i}\mathscr{C}\mathscr{A}_{i}=-k_{n}\mathscr{C}\mathscr{A}_{n}\]</span></p><p><span class="math display">\[\sum_{i=1}^{t}k_{i}\mathscr{A}_{i}\mathscr{C}+\sum_{i=t}^{n-1}k_{i}\mathscr{A}_{i}\mathscr{C}=-k_{n}\mathscr{A}_{n}\mathscr{C}\]</span></p><p>由于对<span class="math inline">\(t+1\leq i\leq n\)</span>, <span class="math inline">\(\mathscr{A}_{i}\mathscr{C}=-\mathscr{C}\mathscr{A}_{i}\)</span>. 故将两式相加, 得到</p><p><span class="math display">\[\sum_{i=1}^{t}k_{i}\mathscr{C}\mathscr{A}_{i}=0\]</span></p><p>而<span class="math inline">\(t\leq n-1\)</span>, 与<span class="math inline">\(n\)</span>的最小性矛盾.</p><p>因此, <span class="math inline">\(M\)</span>中不同且不互为相反数的元素线性无关. 而<span class="math inline">\(\dim M\leq n^{2}\)</span>. 故<span class="math inline">\(\left|M\right|\leq2n^{2}\)</span>. <span class="math inline">\(\square\)</span></p><blockquote><p><strong>问题 2</strong> [Dedekind-Artin] 设<span class="math inline">\(G\)</span>是一个幺半群, <span class="math inline">\(\mathbb{K}\)</span>是一个域 (则<span class="math inline">\(K^{*} := \mathbb{K}-\{0\}\)</span>是一个群). <span class="math inline">\(\sigma_{1},\sigma_{2},\ldots,\sigma_{n}\)</span>是两两不同的非零同态<span class="math inline">\(G\rightarrow K^{*}\)</span>, 则它们在<span class="math inline">\(\mathbb{K}\)</span>上线性无关.</p></blockquote><p>证明: 假设存在这样的一组非零同态, 使得它们在<span class="math inline">\(\mathbb{K}\)</span>上线性无关, 则一定能找到其中元素个数最少的一组. 设<span class="math inline">\(n\)</span>是满足</p><p><span class="math display">\[a_{1}\sigma_{1}+\cdots+a_{n}\sigma_{n}=0,\ a_{i}\in\mathbb{K}\text{不全为}0\]</span></p><p>的最小的正整数. 则<span class="math inline">\(n\geq2\)</span>, <span class="math inline">\(a_{i}\)</span>均不为 0.</p><p>因为<span class="math inline">\(\sigma_{1},\sigma_{2}\)</span>不同, 故<span class="math inline">\(\exists z\in G\)</span>使得<span class="math inline">\(\sigma_{1}(z)\neq\sigma_{2}(z)\)</span>. 对于任意<span class="math inline">\(x\in G\)</span>, 都有 <span class="math display">\[a_{1}\sigma_{1}(xz)+\cdots+a_{n}\sigma_{n}(xz)=0\]</span></p><p>由于<span class="math inline">\(\sigma_{i}\)</span>是同态, 则有</p><p><span class="math display">\[a_{1}\sigma_{1}(z)\sigma_{1}+\cdots+a_{n}\sigma_{n}(z)\sigma_{n}=0\]</span></p><p>两边同除<span class="math inline">\(\sigma_{1}\)</span>并与第一个式子相减, 得</p><p><span class="math display">\[\left(a_{2}\dfrac{\sigma_{2}(z)}{\sigma_{1}(z)}-a_{2}\right)\sigma_{2}+\cdots+\left(a_{n}\dfrac{\sigma_{n}(z)}{\sigma_{1}(z)}-a_{n}\right)\sigma_{n}=0\]</span></p><p>其第一个系数就不为 0, 且比第一个式子少一个元素, 这与<span class="math inline">\(n\)</span>的最小性矛盾.</p><p>因此, 任意一组两两不同的非零同态<span class="math inline">\(G\rightarrow K^{*}\)</span>在<span class="math inline">\(\mathbb{K}\)</span>上线性无关. <span class="math inline">\(\square\)</span></p><blockquote><p><strong>问题 3</strong> [Artin] 设<span class="math inline">\(\mathbb{E}\)</span>为数域, <span class="math inline">\(G\)</span>为<span class="math inline">\(\mathrm{Aut}\mathbb{E}\)</span>的有限子群, 则<span class="math inline">\(\left|G\right|\geq\left[\mathbb{E}:\mathbb{F}\right]\)</span>.</p></blockquote><p>证明: 设<span class="math inline">\(G=\{\sigma_{1}=\mathrm{id},\sigma_{2},\ldots,\sigma_{n}\}\)</span>. 要证<span class="math inline">\(\left[\mathbb{E}:\mathbb{F}\right]\leq\left|G\right|=n\)</span>, 只要证<span class="math inline">\(\mathbb{E}\)</span>上任意<span class="math inline">\(n+1\)</span>个元素在<span class="math inline">\(\mathbb{F}\)</span>上线性相关.</p><p><span class="math inline">\(\forall\alpha_{1},\alpha_{2},\ldots,\alpha_{n},\alpha_{n+1}\in\mathbb{E}\)</span>, 则<span class="math inline">\(\mathbb{E}\)</span>上的线性方程组</p><p><span class="math display">\[\begin{pmatrix}\sigma_{1}(\alpha_{1}) &amp; \sigma_{1}(\alpha_{2}) &amp; \cdots &amp; \sigma_{1}(\alpha_{n+1})\\\sigma_{2}(\alpha_{1}) &amp; \sigma_{2}(\alpha_{2}) &amp; \cdots &amp; \sigma_{2}(\alpha_{n+1})\\\vdots &amp; \vdots &amp;  &amp; \vdots\\\sigma_{n}(\alpha_{1}) &amp; \sigma_{n}(\alpha_{2}) &amp; \cdots &amp; \sigma_{1}(\alpha_{n+1})\end{pmatrix}_{n\times(n+1)}\begin{pmatrix}x_{1}\\x_{2}\\\vdots\\x_{n+1}\end{pmatrix}=0\]</span></p><p>必有非 0 解 (未知数的个数大于方程个数).</p><p>考虑其中包含非 0 元素最少的非零解<span class="math inline">\(\begin{pmatrix}b_{1} &amp; b_{2} &amp; \cdots &amp; b_{m} &amp; 0 &amp; \cdots &amp; 0\end{pmatrix}\)</span>, 其中<span class="math inline">\(b_{i}\neq0,i=1,2,\ldots,m\)</span>. 不妨设<span class="math inline">\(b_{1}=1\)</span>, (否则考虑<span class="math inline">\(\begin{pmatrix}1 &amp; \dfrac{b_{2}}{b_{1}} &amp; \cdots &amp; \dfrac{b_{m}}{b_{1}} &amp; 0 &amp; \cdots &amp; 0\end{pmatrix}\)</span>).</p><p>方程组两边用<span class="math inline">\(\sigma_{i}\)</span>作用, 由<span class="math inline">\(\sigma_{i}\)</span>是同态, 可以得到<span class="math inline">\(\begin{pmatrix}\sigma_{i}(b_{1}) &amp; \sigma_{i}(b_{2}) &amp; \cdots &amp; \sigma_{i}(b_{m}) &amp; 0 &amp; \cdots &amp; 0\end{pmatrix}\)</span>是一组非零解, 其中<span class="math inline">\(\sigma_{i}(b_{1})=\sigma_{i}(1)=1\)</span>. 将两组解相减, 得</p><p><span class="math display">\[\begin{pmatrix}0 &amp; \sigma_{i}(b_{2})-b_{2} &amp; \cdots &amp; \sigma_{i}(b_{m})-b_{m} &amp; 0 &amp; \cdots &amp; 0\end{pmatrix}\]</span></p><p>也是一组非零解. 但这组解比<span class="math inline">\(\begin{pmatrix}b_{1} &amp; b_{2} &amp; \cdots &amp; b_{m} &amp; 0 &amp; \cdots &amp; 0\end{pmatrix}\)</span>含有更少的非零元, 因此它只能是零解, 即</p><p><span class="math display">\[\sigma_{i}(b_{j})=b_{j},\ \forall1\leq i\leq n,\ 1\leq j\leq m\]</span></p><p>由<span class="math inline">\(\mathbb{F}\)</span>的定义知<span class="math inline">\(b_{j}\in\mathbb{F},\ \forall1\leq j\leq m\)</span>. 所以</p><p><span class="math display">\[0=\sum_{j=1}^{n+1}\sigma_{1}(\alpha_{j})b_{j}=\sum_{j=1}^{n+1}\mathrm{id}(\alpha_{j})b_{j}=\sum_{j=1}^{n+1}b_{j}\alpha_{j}\]</span></p><p>这表明<span class="math inline">\(\alpha_{1},\ldots,\alpha_{n+1}\)</span>在<span class="math inline">\(\mathbb{F}\)</span>上线性相关. <span class="math inline">\(\square\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excerpts of Where the Crawdads Sing</title>
      <link href="/2020/07/08/Excerpts-of-Where-the-Crowdads-Sing/"/>
      <url>/2020/07/08/Excerpts-of-Where-the-Crowdads-Sing/</url>
      
        <content type="html"><![CDATA[<p>Excerpts made when reading the novel <em>Where the Crawdads Sing</em>.</p><a id="more"></a><blockquote><p>Secretly Kya hoped not to catch a fish, but she felt a tug, jerked her line, and raised a thick bream, flashing silver and blue. Pa leaned out and snatched it in the net, then sat back, slapping his knee and yahooing like she'd never seen. She grinned wide and they looked into each other's eyes, closing a circuit.</p><p>---- <em>Chapter 7: The Fishing Season</em></p></blockquote><blockquote><p>Sycamore and hickories stretched naked limbs against the dull sky and the relentless wind sucked any joy the winter sun might have spread across the bleakness.</p><p>---- <em>Chapter 11 Croker Sacks Full</em></p></blockquote><blockquote><p>Then the kerosene light flickered, faded, and died. One minute there was a soft circle of the world, and then darkness.</p><p>---- <em>Chapter 11 Croker Sacks Full</em></p></blockquote><blockquote><p>Here - instead of the estuaries and enormous sweeps of grass, as in her marsh - clear water followed as far as she could see through a bright and open cypress forest. Brilliant white herons and storks stood among water lilies and floating plants so green they seemed to glow.</p><p>---- <em>Chapter 26 The Boat Ashore</em></p></blockquote><blockquote><p>Clouds lazed in the folded arms of the hills, then billowed up and drifted away. Some tendrils twisted into tight spirals and traced the warmer ravines, behaving like mist tracking the dank fens of the marsh.</p><p>---- <em>Chapter 27 Out Hog Mountain Road</em></p></blockquote><blockquote><p>Colors, which had been muted by the dimness formed into shapes as they moved into the light.</p><p>---- <em>Chapter 35 The Compass</em></p></blockquote><blockquote><p>Sunsets are never simple. Twilight is refracted and reflected, But never true. Even tide is a disguise Covering tracks, Covering lies.</p><p>We don't care That dusk deceives, We see brilliant colors, And never learn The sun has dropped Beneath the earth. By the time we see the burn.</p><p>Sunsets are in disguise, Covering truth, covering lies.</p><p>---- <em>Chapter 35 The Compass</em></p></blockquote><blockquote><p>Even though she only went to school one day in her life - because the other children harassed her - she educated herself and became a well known naturalist and author. We called her the Marsh Girl; now scientific institutions recognize her as the Marsh Expert.</p><p>---- <em>Chapter 53 Missing Link</em></p></blockquote><blockquote><p>I believe you can put all of the rumors and tall tales aside, I believe you will come to a judgment based on the facts you heard in this courtroom, not the false rumors you have heard for years.</p><p>---- <em>Chapter 53 Missing Link</em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
            <tag> book </tag>
            
            <tag> novel </tag>
            
            <tag> excerpt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试文档</title>
      <link href="/2020/07/04/%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/"/>
      <url>/2020/07/04/%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>此文档用于测试网站兼容性，路人请忽略此文档。</p><a id="more"></a><h2 id="数学测试">数学测试</h2><p>这是一个测试文档，我们将在这里进行网站内容发布的一些测试。</p><p>首先是数学公式测试</p><p>行内公式 <span class="math inline">\(\int_0^1 \sin x dx = -\cos x|_0^1\)</span> 测试。</p><p>行间公式测试 <span class="math display">\[e^{i\pi}=-1\]</span></p><p><span class="math display">\[\left(\dfrac{n+1}{e}\right)^{n}&lt;n!&lt;e\left(\dfrac{n+1}{e}\right)^{n+1}\]</span></p><p><span class="math display">\[\dfrac{1}{2}+\dfrac{1}{3}+\cdots+\dfrac{1}{n}&lt;\ln(n+1)&lt;1+\dfrac{1}{2}+\cdots+\dfrac{1}{n}\]</span></p><p>行间公式测试完毕。</p><h2 id="代码测试">代码测试</h2><p>下面是一段C++代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; <span class="built_in">sqrt</span>(i); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; <span class="built_in">sqrt</span>(i)) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片测试">图片测试</h2><p>下面插入一张图片</p><figure><img src="https://cdn.jsdelivr.net/gh/JunyuanHe/MyBlog/source/_posts/测试文档/wp2497026.jpg" alt><figcaption>世界地图</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 使用说明及测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/04/hello-world/"/>
      <url>/2020/07/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 使用说明及测试 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
